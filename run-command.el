;;; run-command.el --- Run an external command from a context-dependent list -*- lexical-binding: t -*-

;; Copyright (C) 2020-2021 Massimiliano Mirra

;; Author: Massimiliano Mirra <hyperstruct@gmail.com>
;; URL: https://github.com/bard/emacs-run-command
;; Version: 0.1.0
;; Package-Requires: ((emacs "27.1") (friendly-shell-command "0.2.2") (friendly-shell "0.2.4"))
;; Keywords: processes

;; This file is not part of GNU Emacs

;; This file is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 3, or (at your option)
;; any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; For a full copy of the GNU General Public License
;; see <https://www.gnu.org/licenses/>.

;;; Commentary:
;;
;; Leave Emacs less.  Relocate those frequent shell commands to configurable,
;; dynamic, context-sensitive lists, and run them at a fraction of the
;; keystrokes with autocompletion.

;;; Code:

(declare-function helm "ext:helm")
(declare-function helm-make-source "ext:helm")
(defvar helm-current-prefix-arg)

(declare-function ivy-read "ext:ivy")
(defvar ivy-current-prefix-arg)

(declare-function vterm-mode "ext:vterm")
(defvar vterm-kill-buffer-on-exit)
(defvar vterm-shell)

(declare-function term-mode "ext:term")
(declare-function term-emulate-terminal "ext:term")
(defvar term-set-terminal-size)
(defvar term-raw-map)

(eval-when-compile (require 'cl-lib))

(require 'friendly-shell)
(require 'friendly-shell-command)

;;; Customization

(defgroup run-command nil
    "Run an external command from a context-dependent list."
    :group 'convenience
    :prefix "run-command-"
    :link '(url-link "https://github.com/bard/emacs-run-command"))

(defcustom run-command-completion-method
  'auto
  "Completion framework to use to select a command.

- `autodetect' (default): pick helm, ivy, or none, based on active
  global completion mode
- `helm': force use helm
- `ivy': force use ivy
- `completing-read': force use `completing-read'"
  :type '(choice (const :tag "autodetect" auto)
          (const :tag "helm" helm)
          (const :tag "ivy" ivy)
          (const :tag "completing-read" completing-read)))


(defcustom run-command-default-working-dir-function
  (lambda () default-directory)
  "Function which return :working-dir for current buffer.
No take arguments, return string.  Default to get `default-directory'"
  :type 'function)

(defcustom run-command-run-method
  'compile
  "Run strategy.

- `compile' (default): display command output in a `compilation-mode' buffer
- `term': display command output in a `term-mode' buffer"
  :type '(choice (const :tag "Terminal Mode" term)
          (const :tag "Compilation Mode" compile)))

(defcustom run-command-recipes nil
  "List of functions that will produce command lists.

Each function is called without arguments and must return a list of property
lists, where each property list represents a command and has the following
format:

- `:command-name' (string, required): A name for the command, used
  to generate the output buffer name, as well as a fallback in case
  `:display' isn't provided
- `:command-line' (string or function, required): The command
  line that will be executed.  Can be a function to e.g. further
  query the user, and should return a string.
- `:display' (string, optional): A descriptive name that will
  be displayed to the user.
- `:working-dir' (string, optional): Directory to run the command
  in.  If not given, defaults to `default-directory'."

  :type '(repeat function)
  :group 'run-command)

;;; User interface

;;;###autoload
(defun run-command ()
    "Pick a command from a context-dependent list, and run it.

The command list is generated by running the functions configured in
`run-command-recipes'."
    (interactive)
    (run-command--check-experiments)
    (if run-command-recipes
        (pcase run-command-completion-method
            ('auto
             (cond ((and (boundp 'helm-mode) helm-mode)
                    (run-command--helm))
                   ((and (boundp 'ivy-mode) ivy-mode)
                    (run-command--ivy))
                   (t (run-command--completing-read))))
            ('helm (run-command--helm))
            ('ivy (run-command--ivy))
            ('completing-read (run-command--completing-read))
            (_ (error "[run-command] Unrecognized completion method: %s"
                      run-command-completion-method)))
        (error "[run-command] Please customize `run-command-recipes' in order to use `run-command'")))

;;; Utilities
(defun run-command--run (command-spec)
    "Run `COMMAND-SPEC'.  Back end for helm and ivy actions."
    (eval (run-command--from-spec command-spec)))

(defun run-command--from-spec (command-recipe)
    "Transform COMMAND-RECIPE to s-expresion which run this recipe."
    (let* ((command-line (plist-get command-recipe :command-line))
           (command-name (plist-get command-recipe :command-name))
           (working-dir (or (plist-get command-recipe :working-dir)
                            (funcall
                             run-command-default-working-dir-function)))
           (lisp-function (plist-get command-recipe :lisp-function))
           (buffer-name (run-command--get-buffer-name command-name
                                                      working-dir))
           (type (or (plist-get command-recipe :type) 'compile))
           (expr
            (cl-case type
              (compile (run-command--construct-compile-command
                        command-line
                        buffer-name
                        working-dir))
              (interpreter (run-command--construct-intepreter-command
                            command-recipe
                            command-line
                            working-dir))
              (async-shell (run-command--construct-async-shell-command
                            command-recipe
                            command-line
                            buffer-name
                            working-dir)))))
        (if lisp-function
            `(progn
                 ,(if (commandp lisp-function)
                      `(funcall-interactively ,(if (symbolp lisp-function)
                                                  `',lisp-function
                                                  `,lisp-function))
                      `(funcall ,(if (symbolp lisp-function)
                                    `',lisp-function
                                    `,lisp-function)))
                 ,expr)
            expr)))

(defun run-command--construct-intepreter-command (command-recipe
                                                  command-line
                                                  working-dir)
    "From COMMAND-RECIPE to s-expresion which run this recipe as interpreter.
COMMAND-LINE is shell command.  WORKING-DIR is directory from which will run
interpreter."
    (unless command-line
        (error "[run-command] Invalid :command-line in recipe %s"
               command-recipe))
    (when command-line
        (let* ((args (split-string-and-unquote command-line))
            (interpreter (car args))
            (interpreter-args (cdr args)))
         `(friendly-shell
           :interpreter ,interpreter
           :path ,working-dir
           ,@(when interpreter-args `(:interpreter-args ',interpreter-args))))))

(defun run-command--construct-async-shell-command (command-recipe
                                                   command-line
                                                   buffer-name
                                                   working-dir)
    "From COMMAND-RECIPE to s-expresion which run this recipe as async command.
COMMAND-LINE is shell command.  WORKING-DIR is directory from which will run
interpreter.  COMMAND-NAME is name of recipe.  BUFFER-NAME is name of output
buffer"
    (when command-line
        (let ((sentinel (plist-get command-recipe :sentinel))
              (callback (plist-get command-recipe :callback)))
            `(friendly-shell-command-async
              ,command-line
              :path ,working-dir
              :output-buffer ,buffer-name
              :sentinel ,(if (symbolp sentinel)
                             `',sentinel
                             `,sentinel)
              :callback ,(if (symbolp callback)
                             `',callback
                             `,callback)))))

(defun run-command--construct-compile-command (command-line
                                               buffer-name
                                               working-dir)
    "From COMMAND-RECIPE to s-expresion which run this recipe via `compile'.
COMMAND-LINE is shell command.  WORKING-DIR is directory from which will run
interpreter.  COMMAND-NAME is name of recipe.  BUFFER-NAME is name of output
buffer."
    (when command-line
        `(let ((compilation-buffer-name-function
                (lambda (_major-mode-name) ,buffer-name)))
             (setq default-directory ,working-dir)
             (compile ,command-line))))

(defun run-command--get-buffer-name (command-name working-dir)
    "Get name of buffer for run command with COMMAND-NAME in WORKING-DIR."
    (format "%s[%s]" command-name working-dir))

(defun run-command--generate-command-specs (command-recipe)
    "Execute `COMMAND-RECIPE' to generate command specs."
    (let ((command-specs
           (cond
             ((fboundp command-recipe)
              (funcall command-recipe))
             ((and (run-command--experiment--active-p 'static-recipes)
                   (boundp command-recipe))
              (symbol-value command-recipe))
             (t (error "[run-command] Invalid command recipe: %s" command-recipe)))))
        (mapcar #'run-command--normalize-command-spec
                (seq-filter (lambda (spec)
                                (and spec
                                     (or (map-elt spec :command-line)
                                         (and (run-command--experiment--active-p
                                               'run-command-experiment-lisp-commands)
                                              (map-elt spec :lisp-function)))))
                            command-specs))))

(defun run-command--normalize-command-spec (command-spec)
    "Sanity-check and fill in defaults for user-provided `COMMAND-SPEC'."
    (unless (stringp (plist-get command-spec :command-name))
        (error "[run-command] Invalid `:command-name' in command spec: %S"
               command-spec))
    (if (and (run-command--experiment--active-p 'run-command-experiment-lisp-commands)
             (plist-get command-spec :lisp-function))
        (unless (functionp (plist-get command-spec :lisp-function))
            (error "[run-command] Invalid `:lisp-function' in command spec: %S"
                   command-spec))
        (unless (or (stringp (plist-get command-spec :command-line))
                    (functionp (plist-get command-spec :command-line)))
            (error "[run-command] Invalid `:command-line' in command spec: %S"
                   command-spec)))
    (append command-spec
            (unless (plist-member command-spec :display)
                (list :display (plist-get command-spec :command-name)))
            (unless (plist-member command-spec :working-dir)
                (list :working-dir default-directory))
            (unless (plist-member command-spec :scope-name)
                (list :scope-name (abbreviate-file-name
                                   (or (plist-get command-spec :working-dir)
                                       default-directory))))))

(defun run-command--shorter-recipe-name-maybe (command-recipe)
    "Shorten `COMMAND-RECIPE' name when it begins with conventional prefix."
    (let ((recipe-name (symbol-name command-recipe)))
        (if (string-match "^run-command-recipe-\\(.+\\)$" recipe-name)
            (match-string 1 recipe-name)
            recipe-name)))

;;; Completion via helm

(defun run-command--helm ()
    "Complete command with helm and run it."
    (helm :buffer "*run-command*"
          :prompt "Command: "
          :sources (run-command--helm-sources)))

(defun run-command--helm-sources ()
    "Create Helm sources from all active recipes."
    (mapcar #'run-command--helm-source-from-recipe
            run-command-recipes))

(defun run-command--helm-source-from-recipe (command-recipe)
    "Create a Helm source from `COMMAND-RECIPE'."
    (require 'helm-adaptive)
    (let* ((command-specs (run-command--generate-command-specs command-recipe))
           (candidates (mapcar (lambda (command-spec)
                                   (cons (plist-get command-spec :display) command-spec))
                               command-specs)))
        (helm-make-source (run-command--shorter-recipe-name-maybe command-recipe)
            'helm-source-sync
            :action 'run-command--helm-action
            :candidates candidates
            :filtered-candidate-transformer 'helm-adaptive-sort)))

(defun run-command--helm-action (command-spec)
    "Execute `COMMAND-SPEC' from Helm."
    (let* ((command-line (plist-get command-spec :command-line))
           (final-command-line (if helm-current-prefix-arg
                                   (read-string "> " (concat command-line " "))
                                   command-line)))
        (run-command--run (plist-put command-spec
                                     :command-line
                                     final-command-line))))

;;; Completion via ivy

(defvar run-command--ivy-history nil
  "History for `run-command--ivy'.")

(defun run-command--ivy ()
    "Complete command with ivy and run it."
    (unless (window-minibuffer-p)
        (ivy-read "Command: "
                  (run-command--ivy-targets)
                  :caller 'run-command--ivy
                  :history 'run-command--ivy-history
                  :action 'run-command--ivy-action)))

(defun run-command--ivy-targets ()
    "Create Ivy targets from all recipes."
    (mapcan (lambda (command-recipe)
                (let ((command-specs
                       (run-command--generate-command-specs command-recipe))
                      (recipe-name
                       (run-command--shorter-recipe-name-maybe command-recipe)))
                    (mapcar (lambda (command-spec)
                                (cons (concat
                                       (propertize (concat recipe-name "/")
                                                   'face 'shadow)
                                       (plist-get command-spec :display))
                                      command-spec))
                            command-specs)))
            run-command-recipes))

(defun run-command--ivy-action (selection)
    "Execute `SELECTION' from Ivy."
    (let* ((command-spec (cdr selection))
           (command-line (plist-get command-spec :command-line))
           (final-command-line (if ivy-current-prefix-arg
                                   (read-string "> " (concat command-line " "))
                                   command-line)))
        (run-command--run (plist-put command-spec
                                     :command-line final-command-line))))

(defun run-command--ivy-edit-action (selection)
    "Edit `SELECTION' then execute from Ivy."
    (let ((ivy-current-prefix-arg t))
        (run-command--ivy-action selection)))

;;; Completion via completing-read

(defun run-command--completing-read ()
    "Complete command with `completing-read' and run it."
    (let* ((targets (run-command--ivy-targets))
           (choice (completing-read "Command: " targets)))
        (when choice
            (let ((command-spec (cdr (assoc choice targets))))
                (run-command--run command-spec)))))

(provide 'run-command)

;;; Experiments

(defvar run-command-experiments nil)

(defvar run-command--deprecated-experiment-warning t)

(defun run-command--experiment--active-p (name)
    "Return t if experiment `NAME' is enabled, nil otherwise."
    (member name run-command-experiments))

(defun run-command--check-experiments ()
    "Sanity-check the configured experiments.

If experiment is active, do nothing.  If experiment is retired or unknown,
signal error.  If deprecated, print a warning and allow muting further warnings
for the rest of the session."
    (let ((experiments '((static-recipes . retired)
                         (vterm-run-method . active)
                         (run-command-experiment-vterm-run-method . active)
                         (run-command-experiment-function-command-lines . retired)
                         (run-command-experiment-lisp-commands . active)
                         (example-retired .  retired)
                         (example-deprecated . deprecated))))
        (mapc (lambda (experiment-name)
                  (let ((experiment (seq-find (lambda (e)
                                                  (eq (car e) experiment-name))
                                              experiments)))
                      (if experiment
                          (let ((name (car experiment))
                                (status (cdr experiment)))
                              (pcase status
                                  ('retired
                                   (error "[run-command] Experiment `%S' was \
retired, please remove from `run-command-experiments'" name))
                                  ('deprecated
                                   (when run-command--deprecated-experiment-warning
                                       (setq run-command--deprecated-experiment-warning
                                             (not (yes-or-no-p
                                                   (format "Warning: run-command: experiment \
 `%S' is deprecated, please update your configuration. Disable reminder for \
this session?" name))))))
                                  ('active nil)))
                          (error "[run-command] Experiment `%S' does not exist, \
please remove from `run-command-experiments'" experiment-name))))
              run-command-experiments)))

;;; run-command.el ends here
